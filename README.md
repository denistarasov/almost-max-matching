# almost-max-matching
Implementation of algorithm which finds a matching in graph that is almost (0.5x) as good as the maximum one.

Алгоритм нахождения паросочетания в невзвешенном неориентированном графе, отличающегося от наибольшего (по размеру) не более, чем в 2 раза.

## Описание алгоритма

Алгоритм считывает **m** ребер в очередь. Затем он извлекает из нее ребра, начиная с первого, и проверяет, можно ли взять это ребро в паросочетание (критерий добавления: если среди предыдущих добавленных ребер нет такого, у которого одна из вершин совпадает с одной из вершин кандидата на добавление). Получившейся вектор ребер и есть искомое паросочетание.

## Сложность

Пусть **V** -- количество вершин, **E** -- количество ребер. Тогда:

**Считывание:** **O(E)**.

**Solve():** Извлечение из очереди и вставка ребер и помечивание вершин (если их не было среди вершин в паросочетании) в векторе **included_** занимает константное время. Всего таких итераций будет ровно **E**. Поэтому сложность этого шага -- **O(E)**.

**Вывод:** в худшем случае **O(E)**, т.е. в паросочетании лежат все ребра.

**Итоговая сложность:** **O(E)**.

## Доказательство корректности

Пусть M -- максимальное паросочетание, M' -- наше паросочетние, которое вернула программа. Теперь для каждого ребра **edge** из M сопоставим множество ребер M_edge из M' такое, что каждое ребро из множества имеет хотя бы одну смежную с **edge** вершину. Заметим, что в каждом множестве может быть не более, чем 2 ребра (т.к. всего возможно 2 вершины). Другими словами, у каждого ребра из M найдется не более, чем 2 ребра из M' таких, что у них есть смежные вершины.

Теперь заметим, что объединение всех таких множеств M_edge дает M. Докажем это от противного. Допустим это не так, значит существует ребро **edge'** и оно не смежно не с одним из ребер из M. Но это противоречит алгоритму, который добавлял все возможные ребра, не смежные с предыдущими.

Получается: |M| = объединение всех вышеописанных множеств M_edge <= сумма |M_edge| по edge <= 2|M'|.
