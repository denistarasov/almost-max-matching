# almost-max-matching
Implementation of algorithm which finds a matching in graph that is almost (0.5x) as good as the maximum one.

Алгоритм нахождения паросочетания в невзвешенном неориентированном графе, отличающегося от наибольшего (по размеру) не более, чем в 2 раза.

## Описание алгоритма

Алгоритм считывает **m** ребер в очередь. Затем он извлекает из нее ребра, начиная с первого, и проверяет, можно ли взять это ребро в паросочетание (критерий добавления: если среди предыдущих добавленных ребер нет такого, у которого одна из вершин совпадает с одной из вершин кандидата на добавление). Получившейся вектор ребер и есть искомое паросочетание.

## Сложность

Пусть **V** -- количество вершин, **E** -- количество ребер. Тогда:

**Считывание:** **O(E)**.

**Solve():** Извлечение из очереди и вставка ребер и помечивание вершин (если их не было среди вершин в паросочетании) в векторе **included_** занимает константное время. Всего таких итераций будет ровно **E**. Поэтому сложность этого шага -- **O(E)**.

**Вывод:** в худшем случае **O(E)**, т.е. в паросочетании лежат все ребра.

**Итоговая сложность:** **O(E)**.

## Доказательство корректности

Будем доказывать от противного. Рассмотрим случайное ребро в нашем паросочетании. Оно либо есть в оптимальном решении, либо его там нет.
Рассмотрим подробнее второй случай. Если этого ребра нет в оптимальном решении, то вместо него там в худшем случае 2 смежных ребра. Допустим, что такой худший случай получился для всех ребер из нашего паросочетания. Но в таком случае, наше решение содержит ровно в 2 раза меньше ребер, чем оптимальное решение. Но по условию нас устраивает даже такой исход.
